{"name":"Intruderpayloads","tagline":"Collection of personal Burpsuite Intruder payloads and fuzz lists","body":"# IntruderPayloads\r\n## Collection of personal Burpsuite Intruder payloads and fuzz lists\r\n\r\n\r\n\r\n### InjectX to Find XSS\r\n\r\nAuthor: 1N3 @ CrowdShield\r\nWebsite: [https://crowdshield.com](https://crowdshield.com)\r\nDate: 10/29/2015\r\n\r\n### Overview\r\n\r\nIn this tutorial, I will cover a simple technique to identify reflected values in a target web application and easily locate potential XSS vectors. This is accomplished by injecting unique heuristic values automatically via Burpsuite Intruder and using search strings to easily locate reflected values. In order to use this technique, you’ll need Burpsuite along with the custom grep strings and fuzz lists provided in this tutorial to get started. For more advanced tricks covered at the end of this tutorial, you’ll also need Apache and Beef (Browser Exploitation Framework).\r\n\r\n\r\n### Why is this helpful to me?\r\n\r\nUsing this technique allows you to do the following:\r\n\r\n- Find reflected values quickly\r\n- Find the location of all reflected values in the response\r\n- Receive XSS confirmation via heuristic testing and unique strings\r\n- Exploit XSS vectors with certainty\r\n\r\n\r\n### Great! How do I do it?\r\n\r\n1. Download the Burp attack configuration or manual fuzz and grep strings [here](https://github.com/1N3/IntruderPayloads/)\r\n2. Load the attack configuration or manual payload lists from the Burp Intruder menu\r\n3. Copy/paste the request to the Intruder screen and add injection points\r\nNOTE: You’ll need to copy/paste the hostname into the “Host” tab of the Intruder configuration for this to work. \r\n4. Run the attack and analyze the results\r\n5. If XSS is possible, proceed to “real” XSS exploitation\r\n\r\n\r\n### Workflow:\r\n\r\n1. Is the injection point reflected in the response? If yes, goto step 2.\r\n2. If reflected in the response, where in the response is it reflected? Search for “INJECTX” to find all injection points. Go to step 3.\r\n3. Once reflected injection points are found, which characters are being sanitized? Again, search for “INJECTX” in the response and look for the heuristic test characters to see which are still untampered. At a minimum, we’ll need “‘></(). To make this easier, you can create searchable columns in Burpsuite and specify “INJECTX”, “</INJECTX>” and “(INJECTX)” as your grep strings. If these characters or search strings are found, then XSS is possible. Proceed to step 4.\r\n4. If XSS is possible, inject our “real” XSS payloads either through manual browser attempts, Burp Intruder or Repeater to exploit the XSS vector.\r\n\r\n\r\nRemote confirmation via Apache logs can help to keep track of blind XSS injection points and will also list the referring page the XSS loaded along with the source IP. Since we control the iframe_injection.php page, we can inject whatever HTML/JS code we want. \r\n\r\nIn this case, it loads a Beef (Browser Exploitation Framework) hook.js which can be used to launch more advanced XSS/client side attacks.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}